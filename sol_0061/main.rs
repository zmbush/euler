#![feature(core)]
#[macro_use] extern crate libeuler;

use libeuler::traits::PolygonalNumber;
use std::collections::HashMap;
/// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate
/// (polygonal) numbers and are generated by the following formulae:
///
/// Triangle        P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
/// Square          P4,n=n2             1, 4, 9, 16, 25, ...
/// Pentagonal      P5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
/// Hexagonal       P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
/// Heptagonal      P7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
/// Octagonal       P8,n=n(3n−2)        1, 8, 21, 40, 65, ...
///
/// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
///
/// The set is cyclic, in that the last two digits of each number is the first two digits of the
/// next number (including the last number with the first).  Each polygonal type: triangle
/// (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different
/// number in the set.  This is the only set of 4-digit numbers with this property.
///
/// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal
/// type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a
/// different number in the set.
fn main() {
    solutions! {
        sol naive {
            use Polygon::*;

            let mut memo = HashMap::new();

            let octagonal = (0..1000)
                .map(|n| n * (3*n - 2))
                .filter(|&v| v > 999 && v < 10000);

            let not_oct = vec![Heptagonal, Hexagonal, Pentagonal, Square, Triangle];
            for i in octagonal {
                match find_remain(&mut memo, not_oct.clone(), i, i) {
                    Some(v) => return Some(v.iter().sum::<i64>()),
                    _ => {}
                }
            }

            None
        }
    }
}

fn find_remain(memo: &mut HashMap<(Vec<Polygon>, i64), Option<Vec<i64>>>, mut needed: Vec<Polygon>, first: i64, last: i64) -> Option<Vec<i64>> {
    use Polygon::*;

    if needed.len() <= 0 {
        let fst = first / 100;
        let lst = last % 100;
        return if fst == lst {
            Some(vec![last])
        } else {
            None
        };
    }

    let last2 = (last % 100) * 100;

    if memo.contains_key(&(needed.clone(), last)) {
        return memo[&(needed.clone(), last)].clone();
    }


    for i in 10..100 {
        let v = last2 + i;

        for j in 0..needed.len() {
            let poly = needed.remove(j);
            let valid = match poly {
                Triangle =>     v.is_triangular(),
                Square =>       v.is_square(),
                Pentagonal =>   v.is_pentagonal(),
                Hexagonal =>    v.is_hexagonal(),
                Heptagonal =>   v.is_heptagonal(),
                Octagonal =>    v.is_octagonal()
            };

            if valid {
                match find_remain(memo, needed.clone(), first, v) {
                    Some(mut vec) => {
                        vec.push(last);

                        return Some(vec);
                    },
                    _ => {}
                }
            }

            needed.insert(j, poly);
        }
    }
    memo.insert((needed.clone(), last), None);

    None
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum Polygon {
    Triangle,
    Square,
    Pentagonal,
    Hexagonal,
    Heptagonal,
    Octagonal
}
